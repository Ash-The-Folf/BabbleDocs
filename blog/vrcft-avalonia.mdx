---
title: How VRCFaceTracking was ported to Linux (and macOS)
description: An article detailing how VRCFaceTracking was rewritten in Avalonia for Linux and macOS
authors: dfgHiatus
hide_table_of_contents: false
---

# How VRCFaceTracking was ported to Linux (and macOS)

I've been using [VRCFaceTracking](https://github.com/benaclejames/VRCFaceTracking) for quite some time now. At the time of writing this, the better part of 2/3 years.

I've seen its beginnings as a mod, then a console app, then a Windows Form and finally (and currently) a fully fledged WinUI3 application. 

During this time, I have also seen the growth of VR on Linux. I understand [the majority of people who use VR  are on Windows](https://store.steampowered.com/hwsurvey) and by extension users of social VR apps, myself included. I'm writing this on my 11-year old workstation I built back in 2014, and it's seen every version of Windows 10 since.

I believe Linux has a place in the VR scene. More importantly, I wanted to enable my friends to smile and laugh like I'm able to. So, I set out to port VRCFaceTracking to Linux.

{/* truncate */}

## Background

Before getting my hands dirty, I looked around to see if anyone had done any relevant work prior to me. I was able to find a project called [oscavmgr](https://github.com/galister/oscavmgr), but I guess I didn't vibe with it.

Ultimately, I determined there wasn't anyting out there with the features I was looking for. I wanted:

1) A version of the current desktop app to run on Linux, staying true to the original as possible.
1) With some QOL improvements:
    - The ability to search for modules.
    - Add custom themes.
    - And so on.

## The current desktop app

To understand how to port VRCFaceTracking, I needed to understand how the current app is structured. VRCFaceTracking is divided into 3 sub-projects:

1) VRCFaceTracking
    - The "frontend" of the app. What you can see and touch, talks to the backend (below).
1) VRCFaceTracking.Core
    - The "backend" of the app. Handles all the core logic.
1) VRCFaceTracking.SDK
    - What modules implement to be recognized and loaded by VRCFaceTracking.SDK.

In other words, I only needed to recreate the first "VRCFaceTracking" project.

At this point as well, I needed to choose the .NET UI framework I'd be building the app with. I opted to use [Avalonia](https://avaloniaui.net/), as I have used it before with [Babble.NET](https://github.com/Project-Babble/Babble.Net), and it's one of the best frameworks for making cross platform .NET applications (in my biased opinion).

Shoutout to [MamaMiaDev](https://www.mammamia.dev/) for their [amazing tutorial video series on YouTube](https://www.youtube.com/watch?v=1mzM6N4drCU). They helped me understand Avalonia when things got confusing, and their code serves as the solid foundation for this project.

## Crafting the pages

Avalonia uses [AXAML](https://docs.avaloniaui.net/docs/basics/user-interface/introduction-to-xaml), an xml-formatted markdown language to define UI elements. You can think of it as the HTML of a website. I started by defining the home, the output, then the module, the settings and then finally the mutator page in that order.

There isn't too much to write about here, this was mainly boilerplate code. This was, however, the easy part of the project.

## Issues with VRCFaceTracking.Core

With the frontend out of the way, I started to connect the bits and pieces of my new frontend to the backend, VRCFaceTracking.Core. I quickly ran into a number of issues:

### Path Separation

This was by far the most common issue.

#### AvatarConfigFileParser.cs (L24):

Before:
```csharp
foreach (var avatarFile in Directory.GetFiles(userFolder + "\\Avatars"))
```

After:
```csharp
foreach (var avatarFile in Directory.GetFiles(Path.Combine(userFolder, "Avatars")))
```

#### Redirectors.cs (L34), Utils.cs (L34)

Before:
```csharp
public static readonly string CustomLibsDirectory = PersistentDataDirectory + "\\CustomLibs";
```

After:
```csharp
public static readonly string CustomLibsDirectory = Path.Combine(PersistentDataDirectory, "CustomLibs");
```

### Windows-Exclusive Functions

In `MainStandalone.cs L40` `Utils.TimeEndPeriod()` is Windows exclusive. Subsequent calls should check the OS before running.

In `ModuleInstaller.cs L68` `RemoveZoneIdentifier()` applies only to files hosted on the Windows OS. This should also check the OS before running.

### fti_osc

VRCFaceTracking.Core uses an in-house rust library `fti_osc` to process OSC messages. I was able to compile this for macOS and Linux without issue, but proper marshalling needed to be included in the interop file.

Firstly, we need UTF-8 string formatting for marshalled strings on macOS and Linux. We can use `LPUTF8Str`, and an OS preprocessor directive is used to determine which `UnmanagedType` should be used.

```csharp
#if WINDOWS_DEBUG || WINDOWS_RELEASE
    [MarshalAs(UnmanagedType.LPStr)]
#else
    [MarshalAs(UnmanagedType.LPUTF8Str)]
#endif
    public string some_string_name;
```

Secondly, the `fti_osc` class received a number of OS preprocessor directives to determine which library it should load.

```csharp
    public static class fti_osc
    {
#if WINDOWS_DEBUG || WINDOWS_RELEASE
    private const string DllName = "fti_osc.dll";
#elif macOS_DEBUG || macOS_RELEASE
    private const string DllName = "fti_osc.dylib";
#elif LINUX_DEBUG || LINUX_RELEASE
    private const string DllName = "fti_osc.so";
#endif

        /// <summary>
        /// Parses a byte buffer of specified length into a single pointer to an osc message
        /// </summary>
        /// <param name="buffer">The target byte buffer to parse osc from</param>
        /// <param name="bufferLength">The length of <paramref name="buffer"/></param>
        /// <param name="byteIndex">The index of the first byte of the message. This is modified after a message is parsed
        /// This way we can sequentially read messages by passing in the value this int was last modified to be</param>
        /// <returns>Pointer to an OscMessageMeta struct</returns>
        [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr parse_osc(byte[] buffer, int bufferLength, ref int byteIndex);

        /// <summary>
        /// Serializes a pointer to an OscMessageMeta struct into a 4096 length byte buffer
        /// </summary>
        /// <param name="buf">Target write buffer</param>
        /// <param name="osc_template">Target OscMessageMeta to serialize</param>
        /// <returns>Amount of bytes written to <paramref name="buf"/></returns>
        [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int create_osc_message([MarshalAs(UnmanagedType.LPArray, SizeConst = 4096)] byte[] buf, ref OscMessageMeta osc_template);

        /// <summary>
        /// Serializes a pointer to an array of OscMessageMeta structs to a byte array of size 4096
        /// </summary>
        /// <param name="buf">Target byte array</param>
        /// <param name="messages">Array of messages to be contained within the bundle</param>
        /// <param name="len">Length of <paramref name="messages"/></param>
        /// <param name="messageIndex">Index of the last message written to <paramref name="buf"/> before it was filled</param>
        /// <returns></returns>
        [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int create_osc_bundle(
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 4096)] byte[] buf,
            [MarshalAs(UnmanagedType.LPArray)] OscMessageMeta[] messages,
            int len,
            ref int messageIndex);

        /// <summary>
        /// Free memory allocated to OscMessageMeta by fti_osc lib
        /// </summary>
        /// <param name="oscMessage">Target message pointer</param>
        [DllImport(DllName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void free_osc_message(IntPtr oscMessage);
}
```

### Misc

#### VRChat.VRCData

Logic was added to get the user's VRChat OSC folder on macOS/Linux machines:

Before:

```csharp
public static readonly string VRCData = Path.Combine($"{Environment.GetEnvironmentVariable("localappdata")}Low", "VRChat\\VRChat");
```

After:

```csharp
private static string VRCData
    {
        get
        {
#if WINDOWS_DEBUG || WINDOWS_RELEASE
            // On Windows, VRChat's OSC folder is under %appdata%/LocalLow/VRChat/VRChat
            return Path.Combine(
                $"{Environment.GetEnvironmentVariable("localappdata")}Low",
                "VRChat", "VRChat"
            );
#else
            /* On Linux, things are a little different. The above points to a non-existent folder
             * Thankfully, we can make some assumptions based on the fact VRChat on Linux runs through Proton
             * For reference, here is what a target path looks like:
             * /home/USER_NAME/.steam/steam/steamapps/compatdata/438100/pfx/drive_c/users/steamuser/AppData/LocalLow/VRChat/VRChat/OSC/
             * Where 438100 is VRChat's Steam GameID, and the path after "steam" is pretty much fixed */

            // 1) First, get the user profile folder
            // (/home/USER_NAME/)
            string home = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);

            // 2) Then, search for common Steam install paths
            // (/home/USER_NAME/.steam/steam/)
            string[] possiblePaths =
            {
                Path.Combine(home, ".steam", "steam"),
                Path.Combine(home, ".local", "share", "Steam"),
                Path.Combine(home, ".var", "app", "com.valvesoftware.Steam", ".local", "share", "Steam")
            };
            string steamPath = Array.Find(possiblePaths, Directory.Exists) ?? string.Empty;

            // 3) Finally, append the fixed path to find the OSC folder.
            return string.IsNullOrEmpty(steamPath) ?
                throw new DirectoryNotFoundException("Could not detect Steam install!") :
                Path.Combine(steamPath, "steamapps", "compatdata", "438100", "pfx", "drive_c", "users", "steamuser", "AppData", "LocalLow", "VRChat", "VRChat");
#endif
        }
    }
```

It's verbose, but it gets the job done.

#### Validator:

Uses of `Validator.TryValidateObject` in `OscRecvService.cs` and `OscSendService.cs` crash on macOS/Linux.

### PR?

I intend to submit my changes as a PR to the main repo.

## Putting it all together

A little bit of tinkering later, I had a functioning version of the app on Windows. I used my app for a night to see how it would perform, and it was able to keep up just fine. You wouldn't be able to tell the difference in VRChat.

## Bread

On the second night of me testing this, a friend of mine, Bread, joined on me in VRChat in Desktop mode. He was eager to show me something he was working on. 

It turns out he had riced a fresh install of Arch Linux to look just like Windows 7. Very nice:

![bread-screenshot-1](/blog/vrcft-avalonia/bread-screenshot-1.png)

![bread-screenshot-2](/blog/vrcft-avalonia/bread-screenshot-2.png)

Anyways, I tell him about the app I'm working on and offer to send him a copy. At this point I had built and run a copy of the app on my craptop (neofetch below, I use mint btw). 

![neofetch](/blog/vrcft-avalonia/arch-is-overrated-imo.png)

He said sure, and I sent him a copy of the app. It booted up just fine, so he said he would get into VR to try out some of the modules.

One install of [ALVR](https://github.com/alvr-org/alvr) later, the app crashed. But it wasn't with ALVR or its module: I took a look at his log file and determined the app looking for VRChat's OSC in the wrong place! 

So I quickly hardcoded Bread's path into the app:

```
/home/toast/.steam/steam/steamapps/compatdata/438100/pfx/drive_c/users/steamuser/AppData/LocalLow/VRChat/VRChat/OSC/
```

Threw it on Proton Drive, and eagerly waited for him to download it.

And it worked! Ok, his eyes were a little wonky but I suspect this might due to a faulty software update Meta pushed.

We opted to use [ALXR](https://github.com/korejan/ALXR-nightly/), and the issue vanished. Here's Bread!

![bread-screenshot-3](/blog/vrcft-avalonia/bread-screenshot-3.png)

## Packaging
So, with a working app we need a way to get it in the hands of people. I wrote a python script that builds and packages the desktop app to .zip files. Currently we have `x64` and `arm64` builds for Windows, macOS and Linux. Other builds are possible too, if and when needs be I can update the script. Here is the code: 

```python
import os
import shutil
import subprocess
import glob

def run_dotnet_publish(runtime, config, self_contained, framework):
    """Run the dotnet publish command with the specified parameters."""
    cmd = [
        'dotnet', 'publish',
        '-r', runtime,
        '-c', config,
        '--self-contained' if self_contained else '',
        '-f', framework
    ]
    cmd = [part for part in cmd if part]  # Remove empty strings
    print(f"Running: {' '.join(cmd)}")
    subprocess.run(cmd, check=True)

def create_zip(source_dir, zip_name):
    """Create a zip file from the specified directory."""
    # Create zip file
    if os.path.exists(zip_name):
        os.remove(zip_name)

    # Check if directory has content
    if not os.listdir(source_dir):
        print(f"Warning: Directory {source_dir} is empty, skipping zip creation")
        return False

    shutil.make_archive(
        base_name=zip_name[:-4],  # Remove .zip extension
        format='zip',
        root_dir=source_dir,
        base_dir='./'
    )
    print(f"Created: {zip_name}")
    return True

def find_output_directory(bin_dir, framework, runtime):
    """Find the directory containing the published output for a specific framework and runtime."""
    # For Windows-specific frameworks
    if framework.startswith('net') and 'windows' in framework.lower():
        # Convert framework format to directory format (replace - with .)
        dir_framework = framework.replace('-', '.')

        # Check for direct match first
        publish_dir = os.path.join(bin_dir, dir_framework, runtime, 'publish')
        if os.path.exists(publish_dir) and os.listdir(publish_dir):
            return publish_dir

        # Try alternative paths for windows frameworks
        # First try with dots instead of dashes
        alt_path = os.path.join(bin_dir, framework.replace('-', '.'), runtime, 'publish')
        if os.path.exists(alt_path) and os.listdir(alt_path):
            return alt_path

        # Then try with just the base framework (net8.0)
        base_framework = framework.split('-')[0]
        alt_path = os.path.join(bin_dir, base_framework, runtime, 'publish')
        if os.path.exists(alt_path) and os.listdir(alt_path):
            return alt_path
    else:
        # For non-Windows frameworks
        publish_dir = os.path.join(bin_dir, framework, runtime, 'publish')
        if os.path.exists(publish_dir) and os.listdir(publish_dir):
            return publish_dir

    # If we couldn't find it with the specific approaches, do a more general search
    for root, dirs, files in os.walk(bin_dir):
        if root.endswith(os.path.join(runtime, 'publish')) and os.listdir(root):
            return root

    return None

def main():
    # Define the publish configurations
    configs = [
        # runtime, config_name, self_contained, framework
        ('win-x64', 'Windows Release', True, 'net8.0-windows10.0.17763.0'),
        ('win-arm64', 'Windows Release', True, 'net8.0-windows10.0.17763.0'),
        ('osx-x64', 'MacOS Release', True, 'net8.0'),
        ('osx-arm64', 'MacOS Release', True, 'net8.0'),
        ('linux-x64', 'Linux Release', True, 'net8.0'),
        ('linux-arm64', 'Linux Release', True, 'net8.0')
    ]

    # Current directory where the script is run
    current_dir = os.getcwd()

    for runtime, config, self_contained, framework in configs:
        # Run the publish command
        run_dotnet_publish(runtime, config, self_contained, framework)

        # Determine the bin directory
        bin_dir = os.path.join(current_dir, 'bin', config)

        # Find the output directory
        output_dir = find_output_directory(bin_dir, framework, runtime)

        if output_dir and os.listdir(output_dir):
            # Create zip filename
            clean_framework = framework.split('-')[0]  # Get base framework name like 'net8.0'
            zip_filename = f"{runtime}_{clean_framework}.zip"
            if create_zip(output_dir, zip_filename):
                print(f"Successfully created zip for {runtime} with framework {framework}")
        else:
            print(f"Could not find non-empty output directory for {runtime} with framework {framework} in {bin_dir}")
            # Print the directory structure to help debugging
            print("Available directories in bin folder:")
            for root, dirs, files in os.walk(bin_dir):
                print(f"  {root}")
                for d in dirs:
                    print(f"    - {d}")

if __name__ == "__main__":
    main()
```

## The Future 

### Installers

Up next, I want to create installers for Windows, macOS and Linux. I've started work on using [`pup-net`](https://github.com/kuiperzone/PupNet-Deploy), a tool that builds and creates installers with one script.

I could also take the Babble App approach that [curls down a bash script](https://gist.github.com/dfgHiatus/e1bce63cd6be1e8645c3b3adfd5b71a6), and runs that and adds `vrcft` as a path-invokable terminal command.

If you know of any tools, please let me know!

### Localization

Another thing I want to add localization for our app. For reference, the Babble App has been translated into over 12 languages thanks to the help of our amazing community and Crowdin. 

VRCFaceTracking has been translated into 5, and it doesn't come bundled with a language selector. To this end, I've created [an unnoficial Crowdin page]() for this, and translations here are directly applicable to both our app as well as the base app.

### Mobile Builds?!

The starter project contained some sample code to make the app run on Android. I disregarded it during development, but kept it there. With some more tweaking it would be *possible* to port things to Android and iOS.

### The Github

If you want to check out the code for this project we have it here! We also have downloads there as well, feel free to snag a copy. 

<ImageGallery images={[
  "/blog/vrcft-avalonia/app-1.png",
  "/blog/vrcft-avalonia/app-2.png",
  "/blog/vrcft-avalonia/app-3.png",
  "/blog/vrcft-avalonia/app-4.png",
]} />

That does it for me here. I'll keep y'all posted:

\- Hiatus

The Project Babble Team